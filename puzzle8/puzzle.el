(defun debug-print (thing)
  (with-current-buffer "*scratch*"
    (insert (format "%s\n" thing))))

(defun largest-line-length (rows)
  (let ((max-length 0))
    (dolist (row rows)
      (if (> (length row) max-length)
          (setq max-length (length row))))
    max-length))

(defun nth-column (n rows)
  (let ((column ()))
    (dolist (row rows)
      (push (nth n row) column))
    (remove nil (reverse column))))

(defun visible-trees-and-positions (grove)
  (let ((rows (length grove))
        (cols (largest-line-length grove))
        (inside-positions ())
        (visible-trees 0))
    (dotimes (row rows)
      (dotimes (col cols)
        (if (and (> row 0)
                 (< row (1- rows))
                 (> col 0)
                 (< col (1- cols)))
            (push (list row col) inside-positions)
          (setq visible-trees (1+ visible-trees)))))
    (list visible-trees (reverse inside-positions))))

(defun solve-part-one (input)
  (let* ((initial-values (visible-trees-and-positions input))
         (positions (cadr initial-values))
         (visible (car initial-values)))
    (dolist (position positions)
      (let* ((row (car position))
             (col (cadr position))
             (position-value (nth col (nth row input)))
             (position-column (nth-column col input))
             (position-row (nth row input)))
        (let ((visible-left t)
              (visible-right t)
              (visible-up t)
              (visible-down t))
          (dotimes (r (length position-row))
            (if (and (< r col)
                     (>= (nth r position-row) position-value))
                (setq visible-left nil)
              (if (and (> r col)
                       (>= (nth r position-row) position-value))
                  (setq visible-right nil))))
          (dotimes (c (length position-column))
            (if (and (< c row)
                     (>= (nth c position-column) position-value))
                (setq visible-up nil)
              (if (and (> c row)
                       (>= (nth c position-column) position-value))
                  (setq visible-down nil))))
          (if (or visible-left visible-right visible-up visible-down)
              (setq visible (1+ visible))))))
    visible))

(defun solve-part-two (input)
  (let ((positions (cadr (visible-trees-and-positions input)))
        (distances ()))
    (dolist (position positions)
      (let* ((row (car position))
             (col (cadr position))
             (position-value (nth col (nth row input)))
             (position-col (nth-column col input))
             (position-row (nth row input))
             (row-left (reverse (butlast position-row (- (length position-row) col))))
             (row-right (reverse (butlast (reverse position-row) (1+ col))))
             (col-up (reverse (butlast position-col (- (length position-col) row))))
             (col-down (reverse (butlast (reverse position-col) (1+ row))))
             (left 0)
             (up 0)
             (right 0)
             (down 0))
        (let ((blocked nil))
          (dotimes (i (length row-left))
            (if (not blocked)
                (setq left (1+ left)))
            (if (>= (nth i row-left) position-value)
                (setq blocked t))))
        (let ((blocked nil))
          (dotimes (i (length row-right))
            (if (not blocked)
                (setq right (1+ right)))
            (if (>= (nth i row-right) position-value)
                (setq blocked t))))
        (let ((blocked nil))
          (dotimes (i (length col-up))
            (if (not blocked)
                (setq up (1+ up)))
            (if (>= (nth i col-up) position-value)
                (setq blocked t))))
        (let ((blocked nil))
          (dotimes (i (length col-down))
            (if (not blocked)
                (setq down (1+ down)))
            (if (>= (nth i col-down) position-value)
                (setq blocked t))))
        (push (* left up right down) distances)))
    (setq distances (sort distances '>))
    (car distances)))

(defun solve-puzzle (file &optional part-two)
  (let ((input ()))
    (with-temp-buffer
      (insert-file-contents file)
      (goto-char (point-min))
      (while (not (eobp))
        (push (mapcar 'string-to-number
                      (remove "" (split-string (string-trim-right (thing-at-point 'line)) "")))
              input)
        (forward-line)))
    (if part-two
        (solve-part-two (reverse input))
      (solve-part-one (reverse input)))))

(message "%s" (solve-puzzle "input.txt")) ;t))
