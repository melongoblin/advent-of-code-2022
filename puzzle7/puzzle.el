;;; puzzle.el --- Description -*- lexical-binding: t; -*-
(require 'map)

(defun debug-print (thing)
  (with-current-buffer "*scratch*"
    (insert (format "%s\n" thing))))

(defun build-paths (path-strings)
  (let ((paths ())
        (current-string ""))
    (dolist (path (reverse path-strings))
      (if (not (string= "/" path))
          (setq current-string (string-join (list current-string path "/")))
        (setq current-string path))
      (push current-string paths))
    paths))

(defun solve-puzzle (file &optional part-two)
  (with-temp-buffer
    (insert-file-contents file)
    (goto-char (point-min))
    (let ((current-path ())
          (listing-dir nil)
          (current-total-size 0)
          (computed-dirs '()))
      (while (not (eobp))
        (let ((current-line (split-string (string-trim-right (thing-at-point 'line)) " ")))
          (if (and (string= (car current-line) "$")
                   listing-dir)
              (progn
                (setq listing-dir nil)
                (setq all-paths (build-paths current-path))
                (dolist (path all-paths)
                  (if (alist-get path computed-dirs nil nil 'equal)
                      (map-put computed-dirs path (+ (alist-get path computed-dirs nil nil 'equal) current-total-size))
                    (map-put computed-dirs path current-total-size)))
                (setq current-total-size 0)))
          (if (string= (car current-line) "$")
              (if (string= (cadr current-line) "cd")
                  (if (string= (caddr current-line) "/")
                      (setq current-path (list "/"))
                    (if (string= (caddr current-line) "..")
                        (let ((wasted (pop current-path))))
                      (push (caddr current-line) current-path)))
                (if (string= (cadr current-line) "ls")
                    (setq listing-dir t)))
            (if (string-match-p "\\`[0-9]*\\'" (car current-line))
                (setq current-total-size (+ current-total-size (string-to-number (car current-line)))))))
        (forward-line))
      (if listing-dir
          (progn
            (setq listing-dir nil)
            (setq all-paths (build-paths current-path))
            (dolist (path all-paths)
              (if (alist-get path computed-dirs nil nil 'equal)
                  (map-put computed-dirs path (+ (alist-get path computed-dirs nil nil 'equal) current-total-size))
                (map-put computed-dirs path current-total-size)))
            (setq current-total-size 0)))
      (if (not part-two)
          (let ((total-sizes 0))
            (dolist (size computed-dirs)
              (if (<= (cdr size) 100000)
                  (setq total-sizes (+ total-sizes (cdr size)))))
            total-sizes)
        (let* ((root-dir (alist-get "/" computed-dirs nil nil 'equal))
               (total-space 70000000)
               (free-space (- total-space root-dir))
               (needed-space (- 30000000 free-space))
               (sizes ()))
          (debug-print needed-space)
          (dolist (dir computed-dirs)
            (if (>= (cdr dir) needed-space)
                (push (cdr dir) sizes)))
          (car (last (sort sizes '>))))))))

(message "%s" (solve-puzzle "input.txt" t))
